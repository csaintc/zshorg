* Introduction
:LOGBOOK:
- Note taken on [2012-01-30 Mo 11:53] \\
  tangle to the correct  locations; use logbook drawer
- Note taken on [2012-01-29 So 01:15] \\
  Git functions added; prompt added; html export style
:END:

  This is a literate programming zsh configuration written in
  org-mode/org-babel.
    
** History
   Up until January 2012 I used [[https://github.com/robbyrussell/oh-my-zsh][oh-my-zsh]] to configure my shell
   environment. It contains a lot of good ideas and a plethora of tools
   but, it also contains many errors and small mistakes; the code-quality
   overall is lousy.

   After discovering the [[https://github.com/eschulte/emacs24-starter-kit][emacs starter kit]] I thought a lot about a good
   project to start to learn about and use [[http://orgmode.org/worg/org-contrib/babel/][org-babel]] for a literate
   programming adventure.

   I'm usualy slow to take action, considering a lot, thinking ahead as
   many paths as I can -- think of. Since, as of january 3d, oh-my-zsh
   get's on my nerves for a couple of weeks now instead of making my
   day, taking on my first LP project wasn't such a long process after all.

   The first version considered complete enough to replace oh-my-zsh,
   finaly ridden of the command substitution bug, was finished
   <2012-01-10 Tue 13:21>.
** =org-mode= configuration                                   :ignoreExport:
#+TITLE: zsh Configuration
#+STARTUP: overview
#+STARTUP: logdone
#+STARTUP: indent
#+PROPERTY: padline yes
#+PROPERTY: LOG_INTO_DRAWER LOGBOOK
#+EXPORT_EXCLUDE_TAGS: ignoreExport
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+STYLE: <link rel="stylesheet" type="text/css" href="http://orgmode.org/org-manual.css" />
* =zshrc=
#+begin_src sh :tangle ~/.zshrc :noweb tangle :exports code
  <<variables>>
  <<modules>>
  <<aliases>>
  <<functions>>
  <<options>>
  <<keybindings>>
  <<command_completion>>
  <<commandline_editing>>
  <<history>>
  <<dired>>
  <<hooks>>
  <<terminal>>
  <<prompt>>
  <<git>>
#+end_src 

** Variables
:PROPERTIES:
:noweb-ref: variables
:padline: yes
:END:

*** Emacs setup
On different systems emacs 24 will be installed in different
locations; I set =EMACS_BASE= here; aliases etc. later will use it.
#+begin_src sh
  if [ -z "${EMACS_BASE}" ]; then
      EMACS_BASE="/usr"
      export EMACS_BASE
  fi
#+end_src

*** Coloring for standard commands
GREP_COLOR is deprecated. =TODO= Define =GREP_COLORS=
#+begin_src sh 
  export GREP_COLOR='1;32'
#+end_src

*** Pager
#+begin_src sh  
  export PAGER='less'
#+end_src

*** Characterset
#+begin_src sh  
  export LC_CTYPE=$LANG
#+end_src

*** Path/Fpath
Newest GNU R in ~/opt
#+begin_src sh 
  path=( ~/opt/bin $path )
#+end_src

Haskell development.
#+begin_src sh
  path=( ~/.cabal/bin $path )
#+end_src
This should always be the last part of =path= tinkering, as I'm used
to be able to override any executable by putting a replacement or
wrapper in my =~/bin=.
#+begin_src sh  
  path=( ~/bin $path )
#+end_src
Finaly adjust the =fpath=; a lot of the stuff following is tangled
into files autoloadable
#+begin_src sh 
  fpath=( ~/.zsh.d/functions $fpath )
#+end_src 

*** Bashlibs
#+begin_src sh  
  export BASH_LIBS_DIR=~/lib/bash
#+end_src

*** Editor
#+begin_src sh  
  export EDITOR="${EMACS_BASE}/bin/emacsclient -nw -c"
#+end_src

** Modules
:PROPERTIES:
:noweb-ref: modules
:END:

*** =colors=
#+begin_src sh  
  autoload colors; colors
#+end_src

** Aliases
:PROPERTIES:
:noweb-ref: aliases
:END:
*** Coloring for standard commands
A few standard aliases to deal with colored output in terminals.
#+begin_src sh  
  alias ls='ls --color=auto'
  alias grep='grep --color=auto'
  alias less='less -R'
#+end_src
*** Emacs
My emacs installation is sometimes in special locations; the aliases
defined here reflect that.

#+begin_src sh  
  alias emacs="${EMACS_BASE}/bin/emacs"
  alias emc="${EMACS_BASE}/bin/emacsclient -c -nw"  
#+end_src
*** Desktop
I use awesome and don't want =nautilus= to take over my desktop. 
Defining this alias prevents the =nautilus= started by
=gnome-session= to automaticaly take over.

#+begin_src sh 
  alias nautilus='nautilus --no-desktop'  
#+end_src

*** ssh in tmux
#+begin_src sh 
  alias fixtmuxenv='. ~/bin/fixtmuxenv'
  alias ssht='fixtmuxenv && ssh'
#+end_src 

** Functions
:PROPERTIES:
:noweb-ref: functions
:END:
*** Archives
**** Extract
#+begin_src sh  
  function extract() {
      unset REMOVE_ARCHIVE
      
      if test "$1" = "-r"; then
          REMOVE_ARCHIVE=1
          shift
      fi
      if [[ -f $1 ]]; then
          case $1 in
              *.tar.bz2) tar xvjf $1;;
              *.tar.gz) tar xvzf $1;;
              *.tar.xz) tar xvJf $1;;
              *.tar.lzma) tar --lzma -xvf $1;;
              *.bz2) bunzip $1;;
              *.rar) unrar x $1;;
              *.gz) gunzip $1;;
              *.tar) tar xvf $1;;
              *.tbz2) tar xvjf $1;;
              *.tgz) tar xvzf $1;;
              *.zip) unzip $1;;
              *.Z) uncompress $1;;
              *.7z) 7z x $1;;
              *) echo "'$1' cannot be extracted via >extract<";;
          esac
  
          if [[ $REMOVE_ARCHIVE -eq 1 ]]; then
              echo removing "$1";
              /bin/rm "$1";
          fi
  
      else
          echo "'$1' is not a valid file"
      fi
  }  
#+end_src

*** Source bash scripts
#+begin_src sh  
  bash_source() {
      alias shopt=':'
      alias _expand=_bash_expand
      alias _complete=_bash_comp
      emulate -L sh
      setopt kshglob noshglob braceexpand
      
      source "$@"
  }
#+end_src

*** Date from unix timestamp
#+begin_src sh 
  function fromut() {
      echo `perl -e "print scalar(localtime(${1})),\"\n\";"`
  }
#+end_src


*** Attach to tmux session
#+begin_src sh 
  function attach() {
     grabtmuxenv
     if [ -n "$1" ]; then
         tmux -L $1 attach
     else
         tmux attach
     fi 
  }
#+end_src
*** ssh variables
#+begin_src sh 
  function grabtmuxenv() {
      VARS=(SSH_CLIENT SSH_TTY SSH_AUTH_SOCK SSH_CONNECTION DISPLAY
      GNOME_KEYRING_CONTROL GNOME_KEYRING_PID GNOME_DESKTOP_SESSION_ID)
  
      for x in ${VARS} ; do
          (eval echo $x=\$$x) | sed  's/=/="/
                                  s/$/"/
                                  s/^/export /'
      done 1>$HOME/bin/fixtmuxenv
      chmod 600 $HOME/bin/fixtmuxenv
  }
#+end_src


** Options
:PROPERTIES:
:noweb-ref: options
:END:
#+begin_src sh 
  setopt extended_glob \
      glob_complete \
      function_arg_zero \
      hash_cmds \
      hash_dirs \
      multios \
      re_match_pcre
#+end_src

** Keybindings
:PROPERTIES:
:noweb-ref: keybindings
:END:
*** Emacs style keybindings!
#+begin_src sh  
  bindkey -e
#+end_src
** Command completion
:PROPERTIES:
:noweb-ref: command_completion
:END:
*** =compinit=
#+begin_src sh  
  autoload -Uz compinit; compinit
#+end_src

*** Options
   #+begin_src sh 
     unsetopt menu_complete \
         flowcontrol
     
     setopt auto_menu \
         complete_in_word \
         always_to_end
   #+end_src
*** =complist= module
   #+begin_src sh  
     zmodload -i zsh/complist
   #+end_src

*** .zshrc
#+begin_src sh  
  zstyle :compinstall filename "$HOME/.zshrc"
#+end_src

*** Bashcompletion
#+begin_src sh  
  autoload -Uz bashcompinit; bashcompinit
#+end_src

*** Case sensitive, partial word and substring completion
   #+begin_src sh    
     zstyle ':completion:*' matcher-list 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'
   #+end_src
*** Colors/Menu
   #+begin_src sh  
     zstyle ':completion:*' list-colors ''     
     zstyle ':completion:*:*:*:*:*' menu select
   #+end_src
*** Keybindings   
   #+begin_src sh  
     bindkey -M menuselect '^o' accept-and-infer-next-history  
   #+end_src
*** Process completion
   Menu of own processes for kill.
   #+begin_src sh  
     zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#) ([0-9a-z-]#)*=01;34=0=01'
     zstyle ':completion:*:*:*:*:processes' command "ps -u $(whoami) -o pid,user,comm -w -w"     
   #+end_src
*** Hostnames
   #+begin_src sh  
     [ -r /etc/ssh/ssh_known_hosts ] && _global_ssh_hosts=(${${${${(f)"$(</etc/ssh/ssh_known_hosts)"}:#[\|]*}%%\ *}%%,*}) || _ssh_hosts=()
     [ -r ~/.ssh/known_hosts ] && _ssh_hosts=(${${${${(f)"$(<$HOME/.ssh/known_hosts)"}:#[\|]*}%%\ *}%%,*}) || _ssh_hosts=()
     [ -r /etc/hosts ] && : ${(A)_etc_hosts:=${(s: :)${(ps:\t:)${${(f)~~"$(</etc/hosts)"}%%\#*}##[:blank:]#[^[:blank:]]#}}} || _etc_hosts=()       
     
     hosts=(
         "$_global_ssh_hosts[@]"
         "$_ssh_hosts[@]"
         "$_etc_hosts[@]"
         `hostname`
         localhost
     )
     zstyle ':completion:*:hosts' hosts $hosts
   #+end_src
*** Usernames
   Ignore most system users
   #+begin_src sh  
     zstyle ':completion:*:*:*:users' ignored-patterns \
         adm amanda apache avahi beaglidx bin cacti canna clamav daemon \
         dbus distcache dovecot fax ftp games gdm gkrellmd gopher \
         hacluster haldaemon halt hsqldb ident junkbust ldap lp mail \
         mailman mailnull mldonkey mysql nagios \
         named netdump news nfsnobody nobody nscd ntp nut nx openvpn \
         operator pcap postfix postgres privoxy pulse pvm quagga radvd \
         rpc rpcuser rpm shutdown squid sshd sync uucp vcsa xfs
     
     # ... unless we really want to.
     zstyle '*' single-ignored show          
   #+end_src
*** Caching
   Some completions need caching (dpkg, ...)
   #+begin_src sh  
     zstyle ':completion::complete:*' use-cache 1
     zstyle ':completion::complete:*' cache-path ~/.zsh.d/cache/     
   #+end_src   
*** Devserver
#+begin_src sh  
  if [[ -r "/usr/share/bash-completion/devserver" ]]; then
      bash_source /usr/share/bash-completion/devserver
  fi  
#+end_src

** Commandline editing
:PROPERTIES:
:noweb-ref: commandline_editing
:END:
*** Jump to beginning/end of line/word
#+begin_src sh 
  bindkey "^[[H" beginning-of-line
  bindkey "^[[1~" beginning-of-line
  bindkey "^[OH" beginning-of-line
  bindkey "^[[F"  end-of-line
  bindkey "^[[4~" end-of-line
  bindkey "^[OF" end-of-line
  bindkey "^[[1;5C" forward-word
  bindkey "^[[1;5D" backward-word
#+end_src

*** Deletion
#+begin_src sh 
  bindkey '^?' backward-delete-char
  bindkey "^[[3~" delete-char
  bindkey "^[3;5~" delete-char
  bindkey "\e[3~" delete-char
#+end_src 
*** Insert the last shell word again
#+begin_src sh 
  bindkey "^[m" copy-prev-shell-word
#+end_src

*** URLs
#+begin_src sh 
  autoload -U url-quote-magic
  zle -N self-insert url-quote-magic
#+end_src

*** Options
#+begin_src sh  
  setopt no_beep \
      rm_star_wait
#+end_src

*** Syntax highlighting
#+begin_src sh 
  [[ -f ~/.zsh.d/addons/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]] && \
      source ~/.zsh.d/addons/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
#+end_src 

*** sudo
#+begin_src sh 
  run-with-sudo () { LBUFFER="sudo $LBUFFER" }
  zle -N run-with-sudo
  bindkey '^Xs' run-with-sudo  
#+end_src 

*** Empty ^I lists directory
#+begin_src sh  
  complete-or-list() {
      [[ $#BUFFER != 0 ]] && { zle complete-word ; return 0 }
      echo
      ls
      zle reset-prompt
  }
  zle -N complete-or-list
  bindkey '^I' complete-or-list
#+end_src
*** Pipe to
#+begin_src sh 
  typeset -Ag abbreviations
  abbreviations=(
      "Il"    "| less"
      "Ia"    "| awk"
      "Ig"    "| grep"
      "Ieg"   "| egrep"
      "Iag"   "| agrep"
      "Ih"    "| head"
      "Ik"    "| keep"
      "It"    "| tail"
      "Is"    "| sort"
      "Iv"    "| ${VISUAL:-${EDITOR}}"
      "Iw"    "| wc"
      "Ix"    "| xargs"
  )
  
  magic-abbrev-expand() {
      local MATCH
      LBUFFER=${LBUFFER%%(#m)[_a-zA-Z0-9]#}
      LBUFFER+=${abbreviations[$MATCH]:-$MATCH}
      zle self-insert
  }
          
  no-magic-abbrev-expand() {
      LBUFFER+=' '
  }
          
  zle -N magic-abbrev-expand
  zle -N no-magic-abbrev-expand
  bindkey " " magic-abbrev-expand
  bindkey "^x " no-magic-abbrev-expand
  bindkey -M isearch " " self-insert
#+end_src 

** History
:PROPERTIES:
:noweb-ref: history
:END:
*** Variables
   #+begin_src sh 
     HISTFILE=~/.histfile
     HISTSIZE=10000
     SAVEHIST=10000
   #+end_src 
*** Options
#+begin_src sh   
  setopt append_history
  setopt extended_history
  setopt hist_expire_dups_first
  setopt hist_ignore_dups
  setopt hist_ignore_space
  setopt hist_verify
  setopt inc_append_history
  setopt share_history
  setopt hist_fcntl_lock 
  setopt hist_ignore_all_dups
#+end_src

*** Aliases
   =lh= is short for =load history=, =fc= is a =zsh=-builtin to access
   the history. =-R= rereads the history - in this case from the
   standard history file. =-I= only appends new entries from this file
   to the current active history of the shell process.

   #+begin_src sh  
	 alias lh='fc -RI'  
   #+end_src
*** Functions
   #+begin_src sh  
  function zsh_stats() {
    history | awk '{print $2}' | sort | uniq -c | sort -rn | head
  }  
   #+end_src

*** Keybindings
   #+begin_src sh  
  bindkey '^r' history-incremental-search-backward
  bindkey "^[[5~" up-line-or-history
  bindkey "^[[6~" down-line-or-history
  bindkey '^[[A' up-line-or-search
  bindkey '^[[B' down-line-or-search
   #+end_src

*** Substring search
#+begin_src sh 
  [[ -f ~/.zsh.d/addons/zsh-history-substring-search/zsh-history-substring-search.zsh ]] && \
      source ~/.zsh.d/addons/zsh-history-substring-search/zsh-history-substring-search.zsh
#+end_src 

** Jobcontrol
*** Options
#+begin_src sh  
  setopt long_list_jobs
#+end_src

** Autocorrection
I use autocorrection, but define a couple of aliases for commands for
which I don't want correction.
*** Options
#+begin_src sh 
  setopt correct \
      correct_all 
  
#+end_src
*** Aliases
#+begin_src sh 
  alias man='nocorrect man'
  alias mv='nocorrect mv'
  alias mkdir='nocorrect mkdir'
  alias gist='nocorrect gist'
  alias ebuild='nocorrect ebuild'
#+end_src

** Directory traversal and manipulation
:PROPERTIES:
:noweb-ref: dired
:END:
*** Options
#+begin_src sh  
  setopt auto_name_dirs
  setopt auto_pushd
  setopt auto_cd
  setopt pushd_ignore_dups
  setopt pushd_silent
#+end_src
*** Aliases
#+begin_src sh  
  alias ..='cd ..'
  alias cd..='cd ..'
  alias cd...='cd ../..'
  alias cd....='cd ../../..'
  alias cd.....='cd ../../../..'
  alias cd/='cd /'
  
  alias md='mkdir -p'
  alias rd=rmdir
  alias d='dirs -v'  
#+end_src 
*** Functions
#+begin_src sh  
  cd () {
    if   [[ "x$*" == "x..." ]]; then
      cd ../..
    elif [[ "x$*" == "x...." ]]; then
      cd ../../..
    elif [[ "x$*" == "x....." ]]; then
      cd ../../..
    elif [[ "x$*" == "x......" ]]; then
      cd ../../../..
    else
      builtin cd "$@"
    fi
  }
  function mcd() { 
    mkdir -p "$1" && cd "$1"; 
  }    
#+end_src

** Hooks
:PROPERTIES:
:noweb-ref: hooks
:END:
I use hooks in my prompt setup
#+begin_src sh  
  autoload -U add-zsh-hook 
#+end_src

** Terminal
:PROPERTIES:
:noweb-ref: terminal
:END:
*** Colors
#+begin_src sh  
  eval $(dircolors)
#+end_src

*** Title
In =omz_termsupport_preexec= =$(= and =%= are escaped in the second argument to
=function title()=; this is to prevent multiple execution of the =$()=
command -- prompt substitution as used in =title= (option =-P= to
=print=) would execute the command at least once, and confusion of =%=
tags to commands like =date= with prompt =%= tags.
#+begin_src sh 
  function title {
    [ "$DISABLE_AUTO_TITLE" != "true" ] || return
    if [[ "$TERM" == screen* ]]; then
      print -Pn "\ek$1:q\e\\" #set screen hardstatus, usually truncated at 20 chars
    elif [[ "$TERM" == xterm* ]] || [[ $TERM == rxvt* ]] || [[ "$TERM_PROGRAM" == "iTerm.app" ]]; then
     print -Pn "\e]2;$2:q\a" #set window name
     print -Pn "\e]1;$1:q\a" #set icon (=tab) name (will override window name on broken terminal)
    fi
  }
  
  ZSH_THEME_TERM_TAB_TITLE_IDLE="%15<..<%~%<<" #15 char left truncated PWD
  ZSH_THEME_TERM_TITLE_IDLE="%n@%m: %~"
  
  #Appears when you have the prompt
  function omz_termsupport_precmd {
    title $ZSH_THEME_TERM_TAB_TITLE_IDLE $ZSH_THEME_TERM_TITLE_IDLE
  }
  
  #Appears at the beginning of (and during) of command execution
  function omz_termsupport_preexec {
    emulate -L zsh
    setopt no_extended_glob
    local CMD_1=${1[(wr)^(*=*|sudo|ssh|-*)]} #cmd name only, or if this is sudo or ssh, the next cmd
    local CMD_2=${2//\$\(/\\\$(} # ')}
    CMD_1=${CMD_1//\%/%%}          
    CMD_2=${CMD_2//\%/%%}          
    #
    title "${CMD_1}" "%100>...>${CMD_2}%<<"
  }
  
  add-zsh-hook precmd  omz_termsupport_precmd
  add-zsh-hook preexec omz_termsupport_preexec
  
#+end_src

** Prompt
:PROPERTIES:
:noweb-ref: prompt
:END:
*** Module
#+begin_src sh 
  autoload -U promptinit; promptinit
#+end_src

#+BEGIN_SRC sh
  autoload -Uz vcs_info
  zstyle ':vcs_info:*' enable git svn
  precmd() {
      vcs_info
  }
#+END_SRC

#+begin_src sh  
  setopt prompt_subst
#+end_src 



Use my [[prompt_tomte][prompt definition]].
#+begin_src sh  
  prompt tomte
#+end_src

** Git
:PROPERTIES:
:noweb-ref: git
:END:
*** Prompt 
If there is on thing I had to name, that made me crave for oh-my-zsh
it was the right site prompt stating repository state; here are the
functions I ripped from it...
#+begin_src sh  
  function git_prompt_info() {
      ref=$(git symbolic-ref HEAD 2> /dev/null) || return
      echo "$ZSH_THEME_GIT_PROMPT_PREFIX${ref#refs/heads/}$(parse_git_dirty)$ZSH_THEME_GIT_PROMPT_SUFFIX"
  }
  
  function parse_git_dirty() {
      if [[ -n $(git status -s --ignore-submodules=dirty 2> /dev/null) ]]; then
          echo "$ZSH_THEME_GIT_PROMPT_DIRTY"
      else
          echo "$ZSH_THEME_GIT_PROMPT_CLEAN"
      fi
  }
  
  function git_prompt_ahead() {
      if $(echo "$(git log origin/$(current_branch)..HEAD 2> /dev/null)" | grep '^commit' &> /dev/null); then
          echo "$ZSH_THEME_GIT_PROMPT_AHEAD"
      fi
  }
  
  function git_prompt_short_sha() {
      SHA=$(git rev-parse --short HEAD 2> /dev/null) && echo "$ZSH_THEME_GIT_PROMPT_SHA_BEFORE$SHA$ZSH_THEME_GIT_PROMPT_SHA_AFTER"
  }
  
  function git_prompt_long_sha() {
      SH A=$(git rev-parse HEAD 2> /dev/null) && echo "$ZSH_THEME_GIT_PROMPT_SHA_BEFORE$SHA$ZSH_THEME_GIT_PROMPT_SHA_AFTER"
  }
  
  function git_prompt_status() {
      INDEX=$(git status --porcelain 2> /dev/null)
      STATUS=""
      if $(echo "$INDEX" | grep '^?? ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_UNTRACKED$STATUS"
      fi
      if $(echo "$INDEX" | grep '^A  ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_ADDED$STATUS"
      elif $(echo "$INDEX" | grep '^M  ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_ADDED$STATUS"
      fi
      if $(echo "$INDEX" | grep '^ M ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS"
      elif $(echo "$INDEX" | grep '^AM ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS"
      elif $(echo "$INDEX" | grep '^ T ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS"
      fi
      if $(echo "$INDEX" | grep '^R  ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_RENAMED$STATUS"
      fi
      if $(echo "$INDEX" | grep '^ D ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_DELETED$STATUS"
      elif $(echo "$INDEX" | grep '^AD ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_DELETED$STATUS"
      fi
      if $(echo "$INDEX" | grep '^UU ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_UNMERGED$STATUS"
      fi
      echo $STATUS
  }
  
#+end_src

*** Commands
#+begin_src sh  
  autoload -Uz gitaliasinit; gitaliasinit
#+end_src

* Library
:PROPERTIES:
:mkdirp: yes
:END:
** Prompt
*** Tomte
At the moment this is based on the omz theme sorin.
The git stuff has to be replaced by the builtin vcs stuff of zsh.
<<prompt_tomte>>
#+begin_src sh :tangle ~/.zsh.d/functions/prompt_tomte_setup
  function prompt_tomte_setup {
      if [[ "$TERM" != "dumb" ]] && [[ "$DISABLE_LS_COLORS" != "true" ]]; then
          MODE_INDICATOR="%{$fg_bold[red]%}❮%{$reset_color%}%{$fg[red]%}❮❮%{$reset_color%}"
          local return_status="%{$fg[red]%}%(?..⏎)%{$reset_color%}"
          
          PROMPT='%{$fg[blue]%}%m%{$reset_color%}:%{$fg[cyan]%}%c${vcs_info_msg_0_} %(!.%{$fg_bold[red]%}#.%{$fg_bold[green]%}❯)%{$reset_color%} '
          
          
      else 
          MODE_INDICATOR="❮❮❮"
          local return_status="%(?::⏎)"
          
          PROMPT='%c${vcs_info_msg_0_} %(!.#.❯) '
          
     fi      
  }
  
  prompt_tomte_setup "$@"  
#+end_src
** Git
*** Init
#+begin_src sh :tangle ~/.zsh.d/functions/gitaliasinit
  _GITALIAS_DIR=${:-~/.zsh.d/functions/git}
  gitaliasinit() {
      fpath=($_GITALIAS_DIR $fpath)
      for gitalias in $_GITALIAS_DIR/*; do
          if [[ -r $gitalias ]]; then
              name=$gitalias:t
              autoload -Uz $name
          fi
      done
  }
  
  [[ -o kshautoload ]] || gitaliasinit "$@"
#+end_src


*** Add
#+begin_src sh :tangle ~/.zsh.d/functions/git/add
  git add "${argv[@]}"
#+end_src
*** Commit
#+begin_src sh :tangle ~/.zsh.d/functions/git/commit
  git commit "${argv[@]}"
#+end_src
*** Diff
#+begin_src sh :tangle ~/.zsh.d/functions/git/gdiff
  git diff "${argv[@]}"
#+end_src
*** Log
#+begin_src sh :tangle ~/.zsh.d/functions/git/glog
  git log "${argv[@]}"
#+end_src
*** Stat
#+begin_src sh :tangle ~/.zsh.d/functions/git/gstat
  git status "${argv[@]}"
#+end_src
*** Pull
#+begin_src sh :tangle ~/.zsh.d/functions/git/pull
  git pull "${argv[@]}"
#+end_src
*** Push
#+begin_src sh :tangle ~/.zsh.d/functions/git/push
  git push "${argv[@]}"
#+end_src
*** Checkout
#+begin_src sh :tangle ~/.zsh.d/functions/git/checkout
  git checkout "${argv[@]}"
#+end_src
*** Clone
#+begin_src sh :tangle ~/.zsh.d/functions/git/clone
  git clone "${argv[@]}"
#+end_src
